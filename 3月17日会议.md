### 

# API Demo

| 方法名          | 意义                                                            | 参数                   | 返回         |
| ------------ | ------------------------------------------------------------- | -------------------- | ---------- |
| GetBlockHash | Returns hash of block in best-block-chain at height provided. | height-int, required | hex-string |

GetBlockHash的请求命令结构定义在package acbcjson的chainsvrcmd中

# RPC-Client

主要定义在package rpcclient中。

### 包结构梳理

- infrastructure.go 主要定义client的基本类型和结构

- chain.go 主要定义与链相关的发送请求与接收结果的方法与结构

### infrastructure.go

### chain.go

1. GetBlockHash 接收参数
   
   1. GetBlockHashAsync 将参数转化为对应的请求命令（command） json结构体，调用SendCmd函数发送rpc请求命令，返回结果channel
      
      1. SendCmd函数
         
         1. 获得版本号
         
         2. 调用CmdMethod函数获得cmd对应的方法
            
            1. 通过反射获得cmd类型
            
            2. 通过map从cmd类型映射到string方法
         
         3. id自增
         
         4. MarshalCmd返回序列化后cmd方法，便于使用json传输
            
            1. 通过反射获得cmd类型
            
            2. 通过map从cmd类型映射到string方法
            
            3. 通过反射获得cmd值并判断是否为空
            
            4. 调用makeParams函数，按照具体cmd结构字段的顺序创建一个接口值切片，同时将指针字段视为可选参数，并且仅在它们为非零时添加它们。
            
            5. 通过版本、方法、id、params调用NewRequest构建一个JSON-RPC 请求对象
               
               1. 判断版本号是否有效
               
               2. 判断id的type是否有效
               
               3. 构建request对象
            
            6. 序列化
         
         5. 构建一个包含结果channel的jsonRequest对象
         
         6. sendRequest（涉及到并发编程，待具体分析）
            
            1. 根据客户端配置信息判断是HTTP POST模式还是websocket模式
            
            2. 若为HTTP POST模式
               
               1. 若可以批处理，调用addRequest
                  
                  1. 
               
               2. 否则调用sendPostRequest
                  
                  1. 使用一个channel判断 是否关闭
                  
                  2. 将5中jsonRequest对象->给该client的成员
            
            3. 否则检查websocket是否建立
            
            4. 调用addRequest
            
            5. 调用sendMessage
         
         7. 返回结果channel
   
   2. Receive()在结果channel上**阻塞**地接收服务器返回的数据，反序列化为字符串，调用NewHashFromStr
      
      1. NewHashFromStr调用Decode将**翻转过的十六进制编码**的hash字符串（大端）解码成定义为**byte数组**的hash（小端）（这个hash是双重sha256）。
         
         1. Decode函数
            
            1. 将字符串补为偶数长度
            
            2. 调用hex.decode函数（go标准库encoding/hex）解码
            
            3. 翻转并返回

2. 定义getblockhash请求类型

3. 根据不同api封装请求并发送

4. 接收结果并进一步处理

# RPC Server

1. 接受请求，解析请求的API名称，参数值

2. **调用**其它模块的函数

3. 返回结果和error

# 近期目标

1. 找一个具体的协议，数据结构，查看源码，查看其数据链路

2. 搭建基础的RPC Server和RPC-Client

3. 编写测试API，验证RPC Server和RPC-Client可用性

4. 根据其它模块需求，添加各种API函数 3月后

# 疑问

1.  btc中hash大端显示小端存储，是否有特别的用意？

2.  **btcjson/cmdinfo.go**中  这里只是可能并发读map，为什么要上锁？![](/Users/bytedance/Library/Application%20Support/marktext/images/2022-03-17-19-01-26-image.png)

3. **btcjson/cmdparse.go**中，发送请求时，对具体cmd序列化，为什么要先创建一个接口切片，然后对这个接口切片中的每个field序列化，并且将指针视为可选参数，仅当它们非空时才添加它们？
   
   ![](/Users/bytedance/Library/Application%20Support/marktext/images/2022-03-17-19-20-23-image.png)

4.  **btc/rpcclient/infrastructure.go**中，在MarshalCmd函数中，已经封装了一个JSON-RPC Requset，为什么之后又封装一个jsonRequest。应该与服务器的响应有关？（服务器这块还没看完）
   ![](/Users/bytedance/Library/Application%20Support/marktext/images/2022-03-17-19-22-03-image.png)

5. **btc/rpcclient/infrastructure.go**中，addRequest函数，sendPostRequest函数，sendRequest函数，sendMessage函数的并发编程问题。（看完ppt再看一下）
