# 作为代理   6月6日

Proxy：127.0.0.1:8334  在config.go RPCListeners中配置

ModuleFrom：127.0.0.1:8333

ModuleTo：127.0.0.1:8335

服务器接收请求，并将请求转发给相应的模块，然后接收到结果以后，再返回结果给原模块

接收请求，格式为

```go
type Request struct {
    ModuleFrom string            `json:"modulefrom"`
    ModuleTo   string            `json:"moduleto"`
    Method     string            `json:"method"`
    Params     []json.RawMessage `json:"params"`
    ID         interface{}       `json:"id"`
}
```

返回响应，格式为

```go
type Response struct {
    ModuleFrom string          `json:"modulefrom""`
    ModuleTo   string          `json:"moduleto""`
    Result     json.RawMessage `json:"result"`
    Error      *RPCError       `json:"error"`
    ID         *interface{}    `json:"id"`
}
```

## 请求模块(ModuleFrom)

> /acbc/rpcclient/examples/moduleFrom/client.go
> 
> 发出对具体rpc函数的调用请求

全局变量 **ProxyClient**保存与不同代理连接的client ，是模块名(string)到client的映射

#### init

初始化与 代理 连接的rpc client，存入ProxyClient这个Map中（因为可能有多个RPCServer代理）

#### **GetBlockHash**

> 测试用函数，一个通过rpc调用的例子

###### 参数说明：

1. client *rpcclient.Client：指明发出请求的client

2. moduleFrom string, moduleTo string：指明发出请求的模块名 和 接收请求返回结果的模块名，这里 moduleFrom 固定为本模块的名称比如"moduleFromTest"。

3. blockHeight int64：与具体调用函数相关的必要参数，比如这个例子中，就是要通过高度，返回块的hash值，那么参数就只有一个blockHeight

###### 处理逻辑：

1. 将第三部分的参数（与具体调用函数相关的必要参数），封装成一个结构体cmd

2. 通过SendRequest函数发送请求

3. 通过ReceiveFuture函数接收结果

4. 解析结果

## 代理(Proxy)

#### server

        NewRPCServer的时候指定参数Isproxy为true，这样当server接收到请求时，会通过proxyToModule函数调用相应client的SendTo方法，直接发送该request，得到序列化的response响应

#### client

*github.com/MonteCarloClub/acbc/rpcclient/client.go*

ModuleClient定义了代理与不同模块连接的client，在init函数中初始化

通过调用sendTo函数，发送请求，得到响应response，返回序列化的结果



## 响应模块(ModuleTo)

        启动一个rpcserver，指定参数 Isproxy为false，是一个正常响应的rpcserver。

        编写处理具体请求的handle函数，将其注册到RpcHandlers中
